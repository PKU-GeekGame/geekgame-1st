# ranwen's Writeups

这次比赛中我又参与了命题和平台维护工作。作为职业放水大师，在本次比赛中贡献了3+1道难度并不高的题。唯一一道我认为出的高难度题也被非预期解炸烂了。

本人在此次比赛中共出了四道题，分别为：共享的机器、在线解压网站、密码学实践、龙珠模拟器。本文含有这四道题的详细题解，以及一些我本人的想法。



## 共享的机器 (contract)

非常经典而简单的以太坊合约逆向题！

为什么在 Misc 类而不在 Binary 类的原因其实很简单。现在市面上以太坊合约逆向软件都太强大了， 以至于正常写出的代码，使用反编译工具搞出来的代码人类可读性非常高。而这题又涉及到以太坊的函数调用以及数据储存机制等简单的以太坊知识，因此被放到了 Misc 类。

先描述一下做法。在 Etherscan 上点开这个合约地址，点到 Contract 页面，点击 Decompile ByteCode，反编译后得到一个 Vyper 源码。

```python
def storage:
  stor0 is addr at storage 0
  stor1 is uint256 at storage 1
  stor2 is uint256 at storage 2
  stor3 is uint256 at storage 3

def _fallback() payable: # default function
  revert

def unknown7fbf5e5a(uint256 _param1, uint256 _param2) payable: 
  require calldata.size - 4 >= 64
  if stor0 != caller:
      if stor0 != tx.origin:
          if stor1 != sha3(caller):
              if stor1 != sha3(tx.origin):
                  revert with 0, 'caller must be owner'
  stor2 = _param1
  stor3 = _param2

def unknownded0677d(uint256 _param1) payable: 
  require calldata.size - 4 >= 32
  idx = 0
  s = 0
  while idx < 64:
      idx = idx + 1
      s = s or (Mask(256, -4 * idx, _param1) >> 4 * idx) + (5 * idx) + (7 * Mask(256, -4 * idx, stor2) >> 4 * idx) % 16 << 4 * idx
      continue 
  if stor3 != 0:
      revert with 0, 'this is not the real flag!'
  return 1
```

做出这个题不需要对这个 Python like language 有太多了解。

我们看到这个合约看起来只有两个明确能调用的函数。其中第二个函数某些情况下会返回一个 `this is not the real flag!` 的消息。我们猜测 flag 就是在这地方判断的。

仔细观察这个判定 flag 的条件，看起来只是取了一个以太坊存储的值然后判断是否和 0 相等。实际上这是 Etherscan 中的 Panoramix decompiler 的一个 bug。如果你使用的是 ethervm.io 的反编译，是可以看出来这块的判断条件应该是 `stor3!=s`。

那么只需要观察 `s` 的计算方法。我们发现，每次循环 `s` 都会更新四个比特位，且和  `stor2` 以及 `_param1` 中的位置是对应的。具体地，对于每个四个比特，都有 `s=(_param1+5*i+7*stor2)%16`。

显然，这个式子我们可以很容易地从 `stor2` 和 `stor3` 倒推出合法地 `_param1` 的值。那么问题就只剩如何拿到这两个存储的值了。

拿到这个值有两个办法。一个是直接从以太坊上度对应位置的值。只需要随便找一个 geth rpc 提供商就可以查到相关方法。那另外一个方法是，查询最后一条修改了这个存储的交易，之后再分析这个交易。而我们在 Etherscan 中看交易列表。所有调用了这个合约的交易不一定都在 Transactions 中，也可能在 Internal Txns （由别的合约调用它的）。我们发现成功的交易只有两个，一个是创建合约的交易 0xe5cc876b771613b2edb33bcbd0ecd5e4f58db27a54fc879a745d01ce2ebd004e， 一个是神秘地址发送的 0x26c021f066afcd313150ca57bfe828b47f93c4986297b201e4dff02c525a9b2e。我们直接点开这个神秘地址的交易页面，Etherscan 中提供了一个 [State 页面](https://ropsten.etherscan.io/tx/0x26c021f066afcd313150ca57bfe828b47f93c4986297b201e4dff02c525a9b2e#statechange)。我们把三角展开一下，发现下面明确写出了以太坊存储中某个地址的改变情况。我们可以直接得到 `stor2=0x15eea4b2551f0c96d02a5d62f84cac8112690d68c47b16814e221b8a37d6c4d3, stor3=0x293edea661635aabcd6deba615ab813a7610c1cfb9efb31ccc5224c0e4b37372`。之后写一下代码解flag即可。

```python
cipher=0x293edea661635aabcd6deba615ab813a7610c1cfb9efb31ccc5224c0e4b37372
key=0x15eea4b2551f0c96d02a5d62f84cac8112690d68c47b16814e221b8a37d6c4d3
mess=0
for i in range(256//4):
    ci=(cipher>>(4*i))&0xf
    ki=(key>>(4*i))&0xf
    mi=(ci-5*i-7*ki)&0xf
    mess|=mi<<(4*i)
print(int.to_bytes(mess,256//8,'big'))
```

得到 flag `flag{N0_S3cReT_ON_EThEreuM}`。



这题使用 Etherscan 的反编译器或者 ethervm.io 的反编译器均各有利弊。Etherscan 的反编译器人类可读性高，但是有可能会出错。ethervm.io 的反编译器不会出错，但是人类可读性差，需要对以太坊有一定了解才能更快地读完代码。

为什么要出这么一道题。在上届比赛中，有人提议下届应该加个区块链题，出这个题目的任务自然就落在我身上了。我看了下其他其难度，想了想还是出点小水题好。于是有了这么一道题。

该题在出题时，在想如何初始化 key 的值。最开始想放初始化代码里，但是想到这样选手可以直接从创建合约的交易来找到这个值，感觉有点过于简单了，于是采用了另外一种方法：使用其他合约调用这个修改函数。我当时忘了这会在 Etherscan 的 Internal Txns 出现，也忘了留其他函数用来混淆这个交易。因此修改存储的交易就以一种更显眼的方式出现在了 Internal Txns 中。

在比赛快结束时，我在以太坊上发了一个虚假交易，看起来是发了一个 flag 到链上。这个交易的发起者和合约创建者是一样的，没想到还有不少人上钩。总共有 10 个人交了这个假 flag，其中有 5 位最终做出了这道题。



## 在线解压网站 (access)

这题也是比较简单的。做法其实很显然，上传一个 ZIP 压缩文件，这个压缩文件中含有一个软链接文件，链接到 /flag。因此上传解压后读取那个文件的内容，就是 /flag 的内容了。

具体构造压缩文件的方法很简单。在 Linux 下建立一个到 /flag 的软链接，之后使用 `zip -y exp.zip exp` 创建压缩文件。其中 `-y` 表示保留原始软链接形式。[我构造的压缩文件](./sol/access_exp.zip)可在 sol 目录中查看。



这题的想法来自于某个群聊，当时在聊镜像站同步软链接的行为。我就在想能不能拿来出题。在线解压这个场景显然是不错的。之后就是思考用什么格式的压缩包。RAR 是野蛮格式，不好。用 TAR 感觉过于直球了，也不好。于是最终使用了 ZIP 格式。使用 ZIP 解压软链接来读取 flag。

其实 ZIP 还有一个特性，就是其中的路径可以非常丰富。具体地，压缩包的文件路径里头，可以有绝对路径，也可以有父文件夹之类的东西。而利用这个，可以实现对该文件夹外的文件覆盖的行为。其实这题也可以缝一下这个特性，加一个鉴权，需要覆盖配置文件才可以读取 flag。但是由于最开始没准备公开源码，以及咕咕咕，就没加这个点。

某个验题人看到这题时，提出来了读取文件这个地方是不是可以直接做路径穿越。我感觉可以，试了试后发现不行。仔细看了下源码，原来是我这个写法不能匹配到二级路径，所以根本做不了路径穿越。我也懒得改代码了，于是题面里头就有了 "他的网站功能并不完整" 这句话。

## 密码学实践 (ezrsa)

传统艺能：一道看似使用了现代密码学的题，但实际上与其密码学性质本身并没有太大的关系。基本上只要拥有一定的数论知识，阅读代码后就可解出这题。

这道题的两个小题本来对应两个单独的题目。但是由于这两个题都比较简单，为了减少题目数量，减少选手的阅读量，于是我把他拼成了一道题。



先阅读代码，能猜出来应该如何拿到两个 flag。对于第一个 flag，应该可以直接从 Richard 的话中推出 flag。对于第二个 flag，需要构造一个 Alice 的证书，之后使用第一个 flag 类似的方法就可以拿到 flag2。

### Flag1

这部分不是我出的。

先观察一下这个加密部分。显然这个加密是个 ECB 模式的分组密码（即每 32 个字节组成的块都使用同样的密钥以及加密方法）。仔细观察一下，这个加密部分，所有运算均是异或，也没有逻辑跳转之类的东西。异或性质就决定了，密文的每一个比特，都可以表示为明文的某些确定的位以及密文的某些确定的位异或的结果。而这份代码内部，所有的交换部分均是以 8 个字节为最小单位操作的（其实这是一个类似于 MD5 的构造）。因此我们可以直接推出密文的 4 组（每组 8 个字节）以及明文的 4 组之间的对应关系。这个推算部分可以借助程序自动完成，使用 sympy 即可。具体代码就在[解题源码](./sol/ezrsa_sol.py)的前几行。跑出来的结果如下：

```
c ^ key_10 ^ key_14 ^ key_16 ^ key_2 ^ key_20 ^ key_22 ^ key_26 ^ key_28 ^ key_4 ^ key_8
d ^ key_11 ^ key_15 ^ key_17 ^ key_21 ^ key_23 ^ key_27 ^ key_29 ^ key_3 ^ key_5 ^ key_9
a ^ c ^ key_0 ^ key_10 ^ key_12 ^ key_16 ^ key_18 ^ key_22 ^ key_24 ^ key_28 ^ key_30 ^ key_4 ^ key_6
b ^ d ^ key_1 ^ key_11 ^ key_13 ^ key_17 ^ key_19 ^ key_23 ^ key_25 ^ key_29 ^ key_31 ^ key_5 ^ key_7
```

而我们发现，最终输出 flag 前，都会输出一段固定内容的文本。我们可以利用这段明文和密文，进而推出其他明文和密文的结果。

具体地，如果我们用已知密文的第一块异或未知密文的第一块，就可以得到已知明文的第三块(c)和未知明文的第三块异或的值，进而得到未知明文地第三块的值。同理，我们可以得到第四块的值，以及两个关于明文块异或的关系式。简单地解一下就可以得到所有未知明文。

用这个方法解码完整的输出即可得到 flag1。在 flag2 部分也可以用这个方法。

### Flag2

这部分是我出的。题目设计上一些细节没有处理好，也因此产生了一些非预期解。

这题考察点非常简单，就是构造满足特定条件消息的 RSA 密文，即 Alice 的证书。同时提供了一个 RSA 加密的方法，但是在次数以及内容上有一定限制。

同时使用 RSA 加密的消息并不能直接控制。具体地，可以输入两个任意变长字符串，在这两个字符串的后面分别拼接上使用 16 比特整数类型编码的字符串长度，之后再把两个字符串拼接起来。

那么其中一个方法是这样。观察到题目中对 RSA 输入的长度并没有太多的限制（这其实是我在设计题目时忘了的点），而在 RSA 算法中，对输入的密文加上 N 的倍数，并不会改变后续计算过程（因为 RSA 全都是在模 N 的意义下计算的）。因此该题的一个方法就是：key 指定为一个空串，则 Alice 的明文应该是 `Alice\x00\x05\x00\x00`。不妨考虑把这个明文的整数编码加上 `N*(2**16)` 再转回字符串形式。显然，这个处理后的明文的后两位也是`\x00\x00`，再往前的两位大概率是一个很大的数（即名字长度很大）。再往前会有约 256 字节的非 0 字符（即 RSA 的 N）。我们在这个字符串前面补一些 0 字符，就可以使其长度为我们需要的值。我们用这个方法，构造出了名字不是 Alice，但是和名字是 Alice 等价的明文。因此我们之间将这个名字和密钥输入给 God，拿到的证书就可以直接给 Richard 了。这个做法由于是比赛中我看到选手的做法才明白的，我也没有写相关解法的代码。

另外一个方法，即预期解是这样。这个方法利用了 RSA 的乘法同态性。我们观察到 RSA 加密的本质就是求幂，而幂运算显然是保持乘法同态的（即 `(a**c)*(b**c)=(a*b)**c`）。因此如果我们能构造两个明文，其乘起来正好是一个 Alice 的证书，那么我们把这两个明文给 God，把 God 返回的两个整数乘起来，就是 Alice 的证书了。但是注意到，在这个题中，名字不能重复使用，我们没法两次都使用空名字了。我的构造是这样：构造一个数字 2，以及一个 Alice 证书除以二的值。具体地，第一条申请的名字为空，密钥为两个字节的 0 字符。我们需要构造的 Alice 的证书的密钥是两个字节的 0 字符。我们把这个值直接除以二就可以得到这次需要发送的信息。其实这个构造并不好（因为某条消息的长度仍然超过了 RSA 的位数），不过能通过此题。具体构造方法在[解题源码](./sol/ezrsa_sol.py)中。

## 龙珠模拟器 (dragon)

> 我好不容易出一道 500 分的题，你却让我输得这么彻底。

以上便是本人精心设计的一道题被非预期解的故事。

![](./assets/dragon1.png)

在讲这两个小任务的具体做法之前，我先来讲述一下这道题的背景，其中也涉及了一些出题时的想法以及最终算法的构思方法。当然，要首先感谢一下贡献了这题前后端大部分代码，来自北京大学的毕业老学长 ustc_zzzz 土老师。

### 题目背景

这几道题的最原始的起源来源于 2018 年 6 月 发表在 MCBBS 上的[一篇文章](https://www.mcbbs.net/thread-801713-1-1.html)。我和 ustc_zzzz 在一个群里看到了这篇文章，觉得很有意思，但是看到下面的计算规模，觉得对于家用爆破地图种子还是有点太苛刻了。后面我也没有过多关心这个东西了。

转折发生在两个月之后。2018 年 8 月，MCBBS 上又出现了[一篇文章](https://www.mcbbs.net/thread-816891-1-1.html)，讲述了对爆破种子方法的优化，使其在家用电脑上也能几分钟内找到一个地图的种子。这篇文章已经在首页待了超过 3 年了（我写这篇题解的时候还在首页）。在我看了全文之后，大呼有趣。原文作者没有提供代码，于是我自己也写了一份，还封装了一个使用 WASM 的浏览器版本（通过上届的题目就能看出来我对这个东西的热爱了），之后我就经常随时随地爆破服务器地图种子。如果你做过之前土老师在 Hackergame 2020 的题目"超迷你的挖矿模拟器"，看到这篇文章就应该明白这道题的来源以及做法了。也因为我和土老师都看过了这篇文章，所以我在看到这道题的时候就想到了这篇文章的做法，我也成了全场唯一一个预期解。（土老师：至少有一个人是预期解做出来了，题没完全白出）

在看到这篇文章后，我便一直在思考，对抗这种攻击的方法，最好还是使用 Java 自带的随机数生成器。一种对抗方法是显然的，开服的人只需要修改一下村庄生成代码里头的生成参数，例如把 setRandomSeed 中的参数修改一下。但是显然这个方法是治标不治本的，如果攻击者通过某种方法拿到了修改后的参数，还是可以用同样的方法攻击。我希望找到一个可以对抗白盒攻击的方案。

而另外一种看起来治本的方法，也是在原文里头提到的，就是把最后的 nextInt(24) 改成 nextInt(25)。或者说是把随机数生成器最后的取模部分的模数改成一个奇质数。但是这种做法真的治本吗？

我们不妨先聚焦一下 setRandomSeed 函数。其中地图种子，以及末尾加数都是不能控制的，我们只能控制输入的 x 和 y。而只要我们拿到任意某个 setRandomSeed 的结果，就一定能逆推出地图种子。再观察 x 和 y 是怎么影响返回值的。这个函数把 x 和 y 分别乘上一个质数，之后再与前面使用地图种子算出来的数一并相加，进而得到返回值。我们发现，由于 x 和 y 的系数是互质的，使用一点数论方法就能构造出特定的 x 和 y，使得最终乘上系数加和后的结果等于任意值。使用这个方法，我们就能把 setRandomSeed 变成一个简单的模型，即 `s=k+i` ，其中 s 是初始化 Java 随机数生成器的种子，k 是地图种子，i 是我们可以随意控制的整数。

看到这个式子，第一个想法就是差分了。我们让 i 加一，s 也会加一。我们看一下 Java 随机数生成的实现，这是一个经典的线性同余随机数生成器 `state=(state*M+A)%(1<<48)`。如果我们能让初始状态加一，那么第一次的随机状态就会加上 M。

但是注意，初始状态并不是种子。Java 中的实现是：`state=s^M`。如果 M 的最后一位是 0，那么 s 加一后，如果没发生进位（即末位是 0），state 也一定会加一；如果进位了，则结果可能会比较复杂。同理 M 最后一位是 1 的情况下，s 加一，state 就会减一。注意，到这块我们已经成功掌握获取 s 最后一位的方法了。而这个方法可以拓展到 s 的任意一位。

我们已经有了一个初步的 idea 了，剩下就是完善这个想法。实际上这个做法的细节还是有一点多的，具体做法在后续部分会讲。

在2019年有了这个想法后，我一直想出成一道 ctf 题，然而我也一直咕咕咕。直到 2020 年土老师把原始题目出到了 Hackergame 内。在我做出土老师的题后，与土老师聊天的时候，我把我这个想法告诉了他。而今年，我想以这个为原型出一道压轴的密码学题，因此联系了土老师，和他合作完成了这一道题。

以下是两个部分的具体做法。阅读代码的部分省略，请自行理解代码中的逻辑。

### BASIC

这个部分的目的是让大家了解一下 Java 随机数生成的方法。实现方法是比较好找的，比如可以找到 [Java8 中的实现文档](https://docs.oracle.com/javase/8/docs/api/java/util/Random.html)，而各版本的实现也是相同的。我们不妨直接观察一下 nextInt 末端。nextInt 的方法是，获取一个 31 位随机数，之后直接对 X 取模，得到一个 分布在 0 到 X-1 之间的随机数（X 不为 2 的幂的情况下）。其中使用一个 while 循环处理了区间长度不能整除而导致概率不均的情况（这部分情况的概率不大于 `X/(2**31)`），由于这个 while 循环执行多次的概率实在太小，因此我们不太需要考虑这个问题。我们可以直接认为，其是无脑返回一个 31 位随机数对 X 取模的值。

接下来再返回到这题的程序中。我们发现，不同种类的珠子，除了区块大小不一样外，所有的参数都是完全一致的。这也就是说，如果我们使用同一个区块坐标询问两个不同种类的种子出现的位置，那么他们所使用的随机数生成器状态就是完全一致的。我们假设已经拿到了区块坐标 (0,0) 第一类种子的位置 (x1,y1)，那么对于区块坐标 (0,0) 第二类种子的位置 (x2,y2)，计算 x1 时取模前的值，和计算 x2 时取模前的值是一样的，y1 和 y2 同理。而我们有 `x1==state%24`，`x2==state%48`，由于 48 是 24 的倍数，使用简单的数论知识可以知道必定有 `x2%24==x1`，稍微化一下，就知道 `x2==x1` 或者 `x2==x1+24`。y 坐标也同理。即我们通过一个第一类珠子的坐标，就可以推出第二类珠子坐标的 4 种可能的值。同理，我们发现其他所有类的珠子区块大小均是上一类的倍数，因此我们使用这个方法就可以从第一类珠子的位置推到第二类，再推到第三类，最终一直到第七类。注意到第六类和第七类之间可能需要找 `64*64` 个坐标。这个范围其实有点大。但是由于同类可能的坐标之间是没有依赖关系的，因此我们可以并行地完成任务。我比较懒，只写了串行的，在校内网络下跑出这个题的 flag 大概需要 5 分钟。具体源码可以查看 [dragon_sol/task1.py](./sol/dragon_sol/task1.py)。

当然，这题你也可以使用背景所述的破解 Minecraft 地图种子的方法。我特意选取了 24 这个区块大小。

### SUPER

这个部分就是我最终想出的部分了，做法的思路可以参考题目背景所述。我先讲一下非预期解。

众所周知，现在计算机的计算速度都非常快，即便是家用电脑也是十分快速的。我们不妨试试枚举所有有效种子（即 2 的 48 次方）需要多少时间。我使用 C++ 写了个程序，在我本人笔记本的 5800H 下，使用所有的核心进行枚举，枚举完所有情况大约只需要 4 个小时。那么如果你愿意花钱租一个超算，或者白嫖学校的超算，多次尝试，有不小概率爆破出地图种子。（我现在挺像知道 MCBBS 原帖作者是写了什么样的一个程序，显卡都需要跑 2 天才能爆破出所有种子）

那么暴力枚举种子的过程能不能优化呢？当然可以。我们可以不直接枚举种子，而是枚举某个区块的随机数状态。假如我们选取了区块大小为 193 的第二类珠子研究（这个区块大小可以很容易在地图上找到一个珠子），我们可以枚举该位置随机数生成器生成第一个随机数后的全状态。注意到这个全状态中，前 31 位在对 193 取模后就得到了该位置的 x 坐标，即在我们知道，前 31 位对 193 取模的值是固定的。我们每次对前 31 位加上 193 就可以得到一个新的合法状态了。这样我们就把枚举的规模缩小到了 `2**48/193`。在得到合法状态后，可以通过简单的数论求逆的方法来算出原始地图种子，进而推算出其他位置的珠子分布情况。我们结合事先收集好的数据，看看这个推算的分布情况和我们收集到的情况是否一致，如果不一致，说明我们找到的不是地图种子（覆盖的概率其实很小，可以不考虑）。这个做法还可以做进一步的优化以减少时间常数。我本人在听说这个做法后写了个原型验证计算时间，发现我本人的机器在并行跑满的情况下，全部枚举完也只需要 2 分钟左右。因此我们可以快速地拿到地图种子，进而计算出所有珠子的分布位置。

那么之后再讲一下预期解。建议先阅读题目背景部分。

我们不妨先只考虑最后一位的情况，同时假设 M 的后两位是 10。同时我们将 state 分为两部分，高 31 位的 `stateh` 和低 17 位的 `statel`。同时对于所有数字都使用 h 和 l 这两个后缀来表示高 31 位和低 17 位。由于使用了差分的方法，使用`'`来标注不同种子的变量。而 `stateK` 表示生成第 k 个随机数后，生成器的内部状态。我们有 `state0=s^M`。而由随机数生成方式，有 `state1=(state*M+A)%B48`，其中 `B48` 表示 `2**48`。使用扩展欧几里得方法修改 x 和 y 坐标，对种子进行可控差分，使得新种子比旧种子恰好大一。

若 s 的最后一位是 0，那么我们有 `state0'=state0+1`，则有 `state1'=(state1+M)%B48`。不妨先假设加法计算结果没有超过 B48，在最低位时这个概率是足够高的。将其拆开，则有：`state1h'=state1h+Mh+C`，`state1l'=(state1l+Ml)%B17`。其中 C 表示低位有没有产生进位，即 `(state1l+Ml)>=B17`。而我们两次生成的随机 x 坐标满足 `x=state1h%29`，`x'=state1h'%29`。我们发现，如果想使用 `state1h` 推 `state1h'`，几乎所有信息都是已知的（除了大约有一半概率为 0 或 1 的 C）。如果我们考虑一下不同 C 对应的两种情况，然后使用这个方法可以从`x`推测一下 `x'`，如果符合我们的推测，那么 s 的最后一位就很有可能是 1。

但是我们显然也要分析一下最后一位是 1 的情况，来确定其他情况不会产生那么好的分布。此时我们的加法一定会产生进位，进到上一位。则最后一位一定是 0，而上一位，如果 M 的这一位是 0，且没有产生进位操作，那么也有 `state0'=state0+1`。但是我们假设了 M 的倒数第二位是 1，在没有进位的情况下相当于减了 2。则我们有 `state0'=state0-1`。同时，如果这一位还产生了进位，那么 state0 的变化的值将更难以预测。即我们发现，最后一位是 1 的情况下，同时 M 是以 10 结尾的情况下，最后一位得到 `state0'=state0+1` 的概率是很小的，因此使用上面的方法推出`x'`的概率也是很小的。即我们可以判断，如果符合上面的情况，那么 s 的末位大概率是 0。通过多次取样可以保证结果可靠。

如果 M 是以 01 结尾的，仍然采用上述的办法，只是有些地方需要把加减法，以及 0 和 1 换一下，在此不赘述了。M 以 00 结尾和 M 以 11 结尾的情况是类似的，后续部分再讨论。

我们先考虑如何把这个位数拓展到任意位数。我们直接应用末位的方法，但稍作修改。

其中一个问题是，例如我们在算倒数第二位的时候，是做一个步长为 2 的差分。那么有`state0'=state0+2`，则`state1'=(state1+2*M)%B48`。注意到上述做法中我们假设了该部分不会进行取模，但实际上当步长比较大的时候，进行取模 是非常正常的。我们先计算一下`2*M%B48`，那么再计算 `(state1+2*M%B48)+B48` 时，外层的取模最多产生一次减去 B48 的效果。即产生了两种可能，减 B48 或者不减 B48。计算两种情况对 x 变化的影响是容易的，不做赘述。而至此我们从 `x` 推算 `x'` 就有了四种可能，考虑高位取模与不取模，低位进位与不进位。对于剩下部分的分析和上文一致，不做赘述。同时我们发现，当步长较低的时候，由于 M 只有 37 位，因此产生高位取模的概率比较小，可以忽略。而当步长比较长的时候（或者说枚举的位数在低 17 位前），低位一定不会产生进位，不用考虑。因此这两种情况只需要枚举两种可能，比较好写。我在写的时候也只写了这两种。

其实我写代码的做法到这里已经结束了。具体地，我的代码只能应对 M 中 01 分界点部分（如高 11 位也是无法处理的），同时中间几位可能产生四种情况的也没有处理。因此最终只有 25 位左右是可以完全确认的。对于剩下的位数，我写了一份 C++ 代码暴力枚举。

完整代码在 [dragon_sol/](./sol/dragon_sol/) 中。具体执行流程为：执行 task2a.py，将输出作为 task2b.cpp 的输入，而 task2b.cpp 输出的答案就是地图种子的中间产物。修改 task3c.py 中的 result 值为这个，运行就可以自动算出地图种子并提交答案了。

这个过程也可以做并行，然而我比较懒。在我每一位取样 20 次的情况下，跑完 task2a.py 大约需要 2 分钟，剩下两个部分都可以在 1 秒内跑完。

那么这个算法能不能继续改进呢？当然能！

我们刚刚的做法仅是没处理 00 或者 11 之类的情况。不如只考虑 00，11 同理。考虑到所有 00 前面一定会有一个 1（我们可以把对 B48 进位取模认为是对 B48 异或）。我们可以先处理这个 10 交界的部分。之后我们就可以找到一个基础的区块坐标，使 M 为 0 的这一位的种子是 1。之后我们再处理他的下一位。如果下一位是 0，那么和上述情况是一样的。如果下一位是 1，那么我们加一后会一直进位，进而进到 10 交界处，最后发生一次异或 1 的行为。这一次异或 1，就会使得我们得到的 `state0'` 大概率和 `state0+1` 不相等，进而再次使用上述的算法就能确认 s 这一位的值。这个做法可以覆盖所有连续 0 的位置。对于连续 1 的位置方法同理，在此不赘述。

之后我们就可以不需要任何指数级别的枚举，来获得种子的任意位了（但在这题中，由于传入的参数是 32 位整数，过高的位数是无法拿到的）。

如果让我再出一次这道题，我一定把随机数生成器的所有长度至少放大到 4 倍，这样大部分带指数的算法就不能通过了。



这题的非预期解让我感觉浪费了一个很好的 idea。据我观察后台提交日志，至少有两位同学使用的是非预期解的方法。有一位同学似乎采用了和预期解类似的方法，成功缓解了我的自闭。希望采用非预期解的同学耗子尾汁，学习一下预期解的做法。

最后再感谢一下 ustc_zzz 土老师。

